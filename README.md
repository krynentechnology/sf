# SF
<h3>SF programming language</h3>

<p>SF is an object oriented generic programming or hardware definition language for embedded purposes. The name SF was originally meant as an acronym for Structured Forth, but the SF syntax has no resemblance with the Forth programming language syntax and the name is just SF now without hinting to Forth. The SF compiler will be supported by an IDE named <b><i>Prime</i></b> which includes a code/design browser, simulator and (target) debugger. The 'structure' in the SF former name Structured Forth did not imply that Forth has no structure or does not offer structure but that the SF source code layout is forced (<i>like coding standard rules</i>) to improve readability and more modularity and clarity is offered by data structures, strong typing and object oriented techniques.</p>

<p>A Forth compiler-interpreter is an extensible macro-assembler for an abstract stack processor (<i>virtual machine</i>). Forth's postfix notation and its inner construction allows very compact refactored code providing a terminal, an editor, a compiler and an interpreter within 16KB of code for a general 8-bit processor like the Z80 or 6502. The low memory requirement and the interactive debugging feature were a great advantage in the beginning years of programming microprocessors.</p>

<p>SF is intended as a very readable object oriented generic programming or hardware definition language while keeping the unique features from Forth as much as possible. The inner works of SF are still very Forth-like. Infix statements and function calls are translated to postfix statements before being processed. The SF cross-compiler generates as a programming language depending on target system requirements - speed vs code size - native, indirect or token threaded code for a (simulated) micro or soft core processor. As a hardware definition language (HDL) the compiler generates EDIF for programmable logic e.g. an FPGA. A subset of the SF language is supported for HDL synthesis.</p>

<p>The SF cross-compiler is an incremental compiler evaluating all source code (<i>global analysis</i>) used as input for complete - all - target code generation. There are no forward reference declarations required. The SF compiler keeps track of all references (<i>in-memory indexes</i>) by means of a low level database (<i>no query language</i>) also written to disk as a repository for rebuilds, dynamic loading and debugging.</p>
